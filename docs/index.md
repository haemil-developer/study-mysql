### 시작하기 전에 

'저장'기능을 수항하는 곳: 메모리, 디스크

|     |메모리| 디스크    |
|-----|---|--------|
|속도| 빠름 | 느림     |
|영속성| 휘발 | 데이터 보존 |
|가격| 비쌈 | 저렴함    |

[메모리 vs 디스크 성능 비교](https://colin-scott.github.io/personal_website/research/interactive_latency.html)

영속성의 특징 때문에 데이터베이스의 **데이터는 결국 디스크에 저장**되어야 한다.<br>
결국 데이터베이스 성능에 힉샘은 **디스크에 랜덤 접근(I/O)을 최소화** 하는 것.<br>
<br>

- 디스크 접근 최소화 방법
  - 디스크에 매번 왔다갔다 하지말고 메모리에 올라온 데이터로 최대한 요청 처리 (메모리 캐시 히트율을 높인다)
  - 그런데 쌓는중에 메모리가 날아가면 어떡하지? <br>
    -> 로그에 순차적으로 쌓고, 서버 올릴때 한번 씩 순서대로 실행해서 디스크와 정합성 유지하자!
  - 메모리 데이터 유실을 고려해 **WAL (Write Ahead Log)** 를 사용
  <br>

대부분 트랜잭션은 무작위하게 write 가 발생한다.<br>
이를 지연시켜 랜덤I/O 횟수를 줄이는 대신 순차I/O를 발생시켜 정합성 유지

    랜덤I/O: 말 그대로 랜덤하게 데이터를 조회
    순차I/O: 연속된 데이터를 조회

<br>

## index
### 정렬된 자료구조로 탐색범위를 최소화 한다.

    ✓ 인덱스도 테이블이다!
    ✓ 인덱스도 비용이다!
    ✓ 꼭 인덱스로만 해결할 수 있는문제인가?
    ✓ 인덱스를 사용한다는건 조회의 성능을 높이지만, 쓰기의 성능은 낮출 수 밖에 없다. 
        (PK 의 추가, 삭제로 노드의 변형이 일어남으로)

- 탐색(검색)이 빠른 자료구조
  - Hash Map, List, Binary Search Tree ...
<br>
<br>

1. HashMap (key : value)
   - 단건 검색속도 O(1)
   - 범위 탐색 O(N)
   - 전방 일치 탐색 불가 ex) like 'AB%'
2. List
   - 정렬되지 않은 리스트의 탐색 O(N)
   - 정렬된 리스트의 탐색 O(logN)
   - 정렬되지 않은 리스트의 정렬시간 복잡도 O(N) ~ O(N * logN)
   - 치명적 단점: 삽입/삭제 비용이 매우 높음
3. Tree
   - 트리 높이에 따라 시간 복잡도가 결정됨 (-> 트리의 높이를 최소화 하는 것이 중요)
   - 한쪽으로 노트가 치우치지 않도록 균형을 잡아주는 트리 사용 <br>
     ex) Red-Black Tree, B + Tree
4. B+Tree (대부분의 RDBMS 가 채택)
   - 삽입/삭제 시 항상 균형을 이룸
   - 하나의 노드가 여러 개의 자식 노드를 가질 수 있음
   - 리프 노드에만 데이터 존재 (마지막 노드만 값을 가지고 그 위로는 단순히 탐색을 위한 key값 으로만 존재)
     - 연속적인 테이터 접근 시 유리함 <br>
   - [B+Tree 동작 시각화](https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html)

<br>

### 클러스터 인덱스
1. 클러스터 인텍스는 데이터 위치를 결정하는 키 값이다.
2. MySQL 의 PK 는 클러스터 인덱스다.
3. My SQL 에서 PK 를 제외한 모든 인덱스는 PK 를 가지고 있다.

**1. 클러스터 인덱스는 데이터 위치를 결정하는 키 값이다** <br>
- 정렬을 이루고 있고 이 정렬된 순서에 따라 데이터가 결정된다.
- 클러스터 키 위치에 따라서 데이터의 위치가 결정된다.
- 클러스터 키 순서에 따라서 데이터 저장 위치가 변경된다 <br>
  -> 클러스터 키 삽입.갱신시에 성능이슈 발생

**2. MySQL 의 PK 는 클러스터 인덱스다** <br>
- PK 로 Auto Increment vs UUID

**3. My SQL 에서 PK 를 제외한 모든 인덱스는 PK 를 가지고 있다**
- PK 의 사이즈가 인덱스의 사이즈를 결정하게 된다.
- 세컨더리 인덱스 (pk를 제외한 모든 인덱스) 만드로는 데이터를 찾아갈 수 없다. -> 항상 pk 인덱스를 검색해야함
- 장점: 
  - pk를 활용한 검색이 빠름 (특히 범위 검색에 유리함)
  - 커버링에 유리함 (세컨더리 인덱스들이 pk 를 가지고 있기 때문 )

### 주의사항
1. 인덱스 필드를 가공하면 기능하지 않는다.
   - ex) age (int) index <br>
   select * from user where age * 10 = 20 <br>
   select * from user where age = '2' 
2. 복합 인덱스에서는 선두컬럼이 중요하다. (선두 없이는 기능하지 않음)
3. 하나의 쿼리에는 하나의 인덱스만 탄다. (여러 인덱스 테이블을 동시에 탐색하지 않음) 
   - where, order by, group by 혼합 해서 사용 할 때는 인덱스를 잘 고려해야한다.<br>
     (각각 다른 인덱스를 탄다면, where 에서 인덱스로 잘 조회 해놓고도 정렬할때 전체탐색을 하는 상황 밣생)
   - index merge hint 를 사용하는 방법이 있긴함
4. 의도대로 인덱스가 동작하지 않을 수 있다. (explain 으로 항상 확인)
